"""
This file serves as a dataset generator used to evaluate particle filter performance.
"""
import numpy as np
from pyquaternion import Quaternion
from myGym.utils.filter_helpers import  fit_polynomial, create_circle, trajectory_length

class LineGenerator():

    def __init__(self, std, exp_points, distance_limit, workspace_bounds, accelerate = False, dt = 0.2, v = 0.2):
        """
        Parameters:
            std : float (standard deviation of measured noise)
            exp_points : int (The expected value of trajectory points generated by a Poisson distributions)
            distance_limit : float (The minimal distance between two points)
            worskpace_bounds : list of tuples (Every point on the trajectory must be located inside of these x, y, z bounds)
            accelerate : vool (determine whether object moves with constant velocity or acceleration)
        """
        self.std = std
        self.exp_points = exp_points
        self.distance_limit = distance_limit
        if workspace_bounds == None:
            self.workspace_bounds = [(-4,4),(0.3, 5), (0, 5)]
        else:
            self.workspace_bounds = workspace_bounds
        self.dt = dt
        self.accelerate = accelerate
        self.v = v


    def generate_1_trajectory(self):
        num_points = np.random.poisson(lam = self.exp_points)
        if num_points < 2: #Minimum of 2 points for a trajectory
            num_points = 2
        key_points = []
        for i in range(num_points):
            x_range, y_range, z_range = self.workspace_bounds
            x = np.random.uniform(x_range[0], x_range[1])
            y = np.random.uniform(y_range[0], y_range[1])
            z = np.random.uniform(z_range[0], z_range[1])
            while not self.check_min_distance([x, y, z], key_points):
                x = np.random.uniform(x_range[0], x_range[1])
                y = np.random.uniform(y_range[0], y_range[1])
                z = np.random.uniform(z_range[0], z_range[1])
            key_points.append([x, y, z])
        if self.accelerate:
            return self.create_trajectory_const_acc(key_points)
        else:
            return self.create_trajectory_const_vel(key_points)


    def check_min_distance(self, new_point, keypoints):
        for point in keypoints:
            if np.linalg.norm(np.array(new_point) - np.array(point)) < self.distance_limit:
                return False
        return True



    def create_trajectory_const_vel(self, keypoints):
        """
        Creates trajectory between keypoints assuming the object moves with a constant velocity.
        """
        v = 0.2
        lines = []
        rot_lines = []
        starting_rot = None
        for i in range(len(keypoints) - 1):
            start = np.array(keypoints[i])
            end = np.array(keypoints[i + 1])
            length = np.linalg.norm(end - start)
            n = int(length / (v*self.dt))
            line = np.linspace(start, end, n)
            rot_line = self.generate_rotations(line, np.deg2rad(15), starting_rot) #CONSTANTS
            rot_lines.extend(rot_line)
            starting_rot = rot_line[-1]
            lines.append(line)
        lines = tuple(lines)
        trajectory = np.vstack(lines)
        return trajectory, rot_lines


    def create_trajectory_const_acc(self, keypoints):
        """
        Creates trajectory between keypoints assuming the object moves with a constant acceleration.
        """

        lines = []
        rot_lines = []
        starting_rot = None
        starting_vel = None
        for i in range(len(keypoints) - 1):
            line, starting_vel = self.const_acc_single_line(np.array(keypoints[i]), np.array(keypoints[i + 1]), starting_vel)
            lines.append(line)
            #print("Line:", line)
            rot_line = self.generate_rotations(line, np.deg2rad(15), starting_rot)  # CONSTANTS
            rot_lines.extend(rot_line)
            starting_rot = rot_line[-1]
        lines = tuple(lines)
        trajectory = np.vstack(lines)
        return  trajectory, rot_lines




    def const_acc_single_line(self, start, end, starting_vel):
        """
        Creates single line simulating object moving with constant acceleration.
        """
        avg_velocity = np.random.uniform(0.1, 0.3)  # CONSTANTS
        v_max = 2*avg_velocity
        if starting_vel is None:
            v1 = np.random.uniform(0, avg_velocity * 2)
        else:
            v1 = starting_vel #Starting velocity
        v2 = 2 * avg_velocity - v1 #Ending velocity
        length = np.linalg.norm(end - start)
        t = length / avg_velocity
        a = (v2 - v1)/ t #acceleration
        n = int(t/self.dt)
        t_vec = np.linspace(0, t, n)
        v = v1 + a*t_vec
        print("---------LINE--------------")
        print("Average_velocity: ", avg_velocity)
        print("Starting velocity:", v1)
        print("Ending velocity:", v2)
        print("Acceleration:", a)
        print("Length:", length)
        print("t: ", t)
        print("Velocity vector:", v)
        direction_vector = (end - start)/length #Direction vector of length one
        trajectory = np.zeros((n, 3))
        for i in range(n):
            trajectory[i, :] = start + (v[i] + v[0])/2 * direction_vector * t_vec[i]
        return trajectory, v[-1] #Also returning final velocity



    def generate_n_trajectories(self, n):
        trajs = []
        for i in range(n):
            trajs.append(self.generate_1_trajectory())
        return trajs


    def save_trajectories(self, trajectories):
        pass



    def generate_rotations(self, trajectory, omega, starting_rot = None):
        """Generates interpolated rotational trajectory for given trajectory."""
        print("starting rot:", starting_rot)
        start_point = trajectory[0]
        end_point = trajectory[-1]
        if starting_rot is None:
            q1 = Quaternion.random()
        else:
            q1 = starting_rot
        q2 = Quaternion.random()
        while not self.check_rotation_distance(q1,q2,start_point, end_point, omega):
            q2 = Quaternion.random()
        rotations = []
        for rot in Quaternion.intermediates(q1, q2, trajectory.shape[0]):
            rotations.append(rot)
        return rotations




    def check_rotation_distance(self, q1, q2, start_point, end_point, omega):
        s = np.linalg.norm(end_point - start_point)
        v = self.v
        max_angle_diff = omega*s/v
        if Quaternion.absolute_distance(q1,q2)*2 > max_angle_diff:
            return False
        return True




class CircleGenerator():
    """
    Class for generating circles inside workspace bounds.
    Parameters:
        std : float (standard deviation of measured noise)
        workspace_bounds: list of tuples (Every point on the trajectory must be located inside of these x, y, z bounds)
        dt : float (Time that passes between each measurement)
        r_min : float (minimal radius for circle generation)
        r_max : float (maximal radius for circle generation)
    """

    def __init__(self, std, workspace_bounds = None, dt = 0.2, r_min = 0.2, r_max = 2, velocity = 0.2):
        self.std = std
        if workspace_bounds == None:
            self.workspace_bounds = [(-4,4),(0.3, 5), (0, 5)]
        else:
            self.workspace_bounds = worskpace_bounds
        self.dt = dt
        self.r_min = r_min
        self.r_max = r_max
        self.v = velocity


    def generate_1_circle(self):
        """Circle generation function"""
        r = np.random.uniform(self.r_min, self.r_max)
        normal = np.random.rand(3)
        center_x = np.random.uniform(self.workspace_bounds[0][0] + r, self.workspace_bounds[0][1] -r)
        center_y = np.random.uniform(self.workspace_bounds[1][0] + r, self.workspace_bounds[1][1] -r)
        center_z = np.random.uniform(self.workspace_bounds[2][0] + r, self.workspace_bounds[2][1] -r)
        center = np.array([center_x, center_y, center_z])
        return self.create_trajectory(center, r, normal)



    def create_trajectory(self, center, radius, normal):
        """
        Create circular trajectory of n points.
        """
        length = 2*np.pi*radius
        n = int(length / (self.v*self.dt))

        trajectory = create_circle(radius, center, normal, n)
        rotation_trajectory = self.generate_rotations(trajectory, np.deg2rad(25))
        return trajectory, rotation_trajectory



    def generate_rotations(self, trajectory, omega, starting_rot = None):
        """Generates interpolated rotational trajectory for given trajectory."""
        if starting_rot is None:
            q1 = Quaternion.random()
        else:
            q1 = starting_rot
        q2 = Quaternion.random()
        while not self.check_rotation_distance(q1,q2,trajectory, omega):
            q2 = Quaternion.random()
        rotations = []
        for rot in Quaternion.intermediates(q1, q2, trajectory.shape[0]):
            rotations.append(rot)
        return rotations


    def check_rotation_distance(self, q1, q2, trajectory, omega):
        """Checks whether or not two rotations too spatially close to each other are not too different."""
        s = trajectory_length(trajectory)
        v = self.v
        max_angle_diff = omega * s / v
        if Quaternion.absolute_distance(q1, q2) * 2 > max_angle_diff:
            return False
        return True

class SplineGenerator():

    def __init__(self, std, exp_points, distance_limit, workspace_bounds = None, dt = 0.2, velocity = 0.2):
        self.std = std
        if workspace_bounds == None:
            self.workspace_bounds = [(-2,2),(0.3, 3), (0, 2)]
        else:
            self.workspace_bounds = worskpace_bounds
        self.dt = dt
        self.exp_points = exp_points
        self.v = velocity
        self.distance_limit = distance_limit



    def generate_1_spline(self):
        num_points = np.random.poisson(lam = self.exp_points)
        if num_points < 3: #Minimum of 3 points for a spline
            num_points = 3
        key_points = []
        for i in range(num_points):
            x_range, y_range, z_range = self.workspace_bounds
            x = np.random.uniform(x_range[0], x_range[1])
            y = np.random.uniform(y_range[0], y_range[1])
            z = np.random.uniform(z_range[0], z_range[1])
            while not self.check_min_distance([x, y, z], key_points):
                x = np.random.uniform(x_range[0], x_range[1])
                y = np.random.uniform(y_range[0], y_range[1])
                z = np.random.uniform(z_range[0], z_range[1])
            key_points.append([x, y, z])
        return self.create_trajectory(key_points)


    def check_min_distance(self, new_point, keypoints):
        for point in keypoints:
            if np.linalg.norm(np.array(new_point) - np.array(point)) < self.distance_limit:
                return False
        return True


    def create_trajectory(self, keypoints):
        keypoints = np.array(keypoints)
        trajectory = np.zeros((40, 3))
        trajectory[:, :3] = fit_polynomial(keypoints, 40)
        new_n = int(trajectory_length(trajectory)/(self.v * self.dt))
        trajectory = fit_polynomial(keypoints, new_n)
        starting_rot = None
        rotations = []
        for i in range(len(keypoints) - 1):
            rotations.extend(self.generate_rotations(trajectory, keypoints[i], keypoints[i + 1], np.deg2rad(25), starting_rot))
            starting_rot = rotations[-1]
        rotations.append(rotations[-1])
        #print("Full rotations: ", rotations)
        return trajectory, rotations


    def generate_rotations(self, trajectory, start, end, omega, starting_rot = None):
        """Generates interpolated rotational trajectory for given trajectory."""
        if starting_rot is None:
            q1 = Quaternion.random()
        else:
            print("Starting rotation: ", starting_rot)
            q1 = starting_rot

        q2 = Quaternion.random()
        start_row = np.argmin(np.linalg.norm(trajectory - start, axis=1))
        # if start_row != 0:
        #     start_row += 1
        end_row = np.argmin(np.linalg.norm(trajectory - end, axis=1))
        print("Starting rotation quaternion for section", start_row, "-", end_row, " : ", q1)
        trajectory_section = trajectory[start_row:end_row, :]
        while not self.check_rotation_distance(q1,q2,trajectory_section, omega):
            q2 = Quaternion.random()
        rotations = []
        for rot in Quaternion.intermediates(q1, q2, trajectory_section.shape[0]):
            rotations.append(rot)
        print("First rotations for section", start_row, "-", end_row, " : ", rotations[1])
        print("First rotations for section", start_row, "-", end_row, " : ", rotations[2])
        print("First rotations for section", start_row, "-", end_row, " : ", rotations[3])
        print("Last rotations for section", start_row, "-", end_row, " : ", rotations[-3])
        print(rotations[-2])
        print("Ending rotation quaternion for section", start_row, "-", end_row, " : ", rotations[-1])
        print("--------------NEW SECTION----------------------")
        return rotations


    def check_rotation_distance(self, q1, q2, trajectory_section, omega):
        """Checks whether or not two rotations too spatially close to each other are not too different."""
        s = trajectory_length(trajectory_section)
        #print("Trajectory section length: ", s, "Trajectory section points: ", trajectory_section.shape[0])
        v = self.v
        max_angle_diff = omega * s / v
        if Quaternion.absolute_distance(q1, q2) * 2 > max_angle_diff:
            return False
        return True








if __name__ == '__main__':
    generator = LineGenerator(0.02, 3, 0.2, [(-4,4),(0.3, 5), (0, 5)], accelerate=True)
    # generator2 = SplineGenerator(0.02, 4, 0.35)
    #generator3 = SplineGenerator(0.02, 4, 0.35)
    # print(generator2.generate_1_spline())
    #print(generator3.generate_1_spline())
    #q1 = Quaternion.random()
    #q2 = -q1
    #print(q1, q2)
    #print("Absolute distance:", Quaternion.absolute_distance(q1, q2))
    #print("Distance:", Quaternion.sym_distance(q1,q2))
    #q1 = Quaternion(axis = (0, 1, 0), degrees = 135)
    #q2 = Quaternion(axis = (0, 1, 0), degrees = 180)
    #print(Quaternion.distance(q2, q1))
    #print(np.pi/8)
    print(generator.generate_1_trajectory())



